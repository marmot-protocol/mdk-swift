// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(mdk_uniffiFFI)
import mdk_uniffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_mdk_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_mdk_uniffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureMdkUniffiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Main MDK instance with SQLite storage
 */
public protocol MdkProtocol: AnyObject, Sendable {
    
    /**
     * Accept a welcome message
     */
    func acceptWelcome(welcome: Welcome) throws 
    
    /**
     * Accept a welcome message from JSON
     */
    func acceptWelcomeJson(welcomeJson: String) throws 
    
    /**
     * Add members to a group
     */
    func addMembers(mlsGroupId: String, keyPackageEventsJson: [String]) throws  -> UpdateGroupResult
    
    /**
     * Create a new group
     */
    func createGroup(creatorPublicKey: String, memberKeyPackageEventsJson: [String], name: String, description: String, relays: [String], admins: [String]) throws  -> CreateGroupResult
    
    /**
     * Create a key package for a Nostr event
     */
    func createKeyPackageForEvent(publicKey: String, relays: [String]) throws  -> KeyPackageResult
    
    /**
     * Create a message in a group
     */
    func createMessage(mlsGroupId: String, senderPublicKey: String, content: String, kind: UInt16, tags: [[String]]?) throws  -> String
    
    /**
     * Decline a welcome message
     */
    func declineWelcome(welcome: Welcome) throws 
    
    /**
     * Decline a welcome message from JSON
     */
    func declineWelcomeJson(welcomeJson: String) throws 
    
    /**
     * Get a group by MLS group ID
     */
    func getGroup(mlsGroupId: String) throws  -> Group?
    
    /**
     * Get all groups
     */
    func getGroups() throws  -> [Group]
    
    /**
     * Get members of a group
     */
    func getMembers(mlsGroupId: String) throws  -> [String]
    
    /**
     * Get a message by event ID within a specific group
     *
     * # Arguments
     *
     * * `mls_group_id` - The MLS group ID the message belongs to (hex-encoded)
     * * `event_id` - The Nostr event ID to look up (hex-encoded)
     *
     * # Returns
     *
     * Returns the message if found, None otherwise
     */
    func getMessage(mlsGroupId: String, eventId: String) throws  -> Message?
    
    /**
     * Get messages for a group with optional pagination
     *
     * # Arguments
     *
     * * `mls_group_id` - Hex-encoded MLS group ID
     * * `limit` - Optional maximum number of messages to return (defaults to 1000 if None)
     * * `offset` - Optional number of messages to skip (defaults to 0 if None)
     *
     * # Returns
     *
     * Returns a vector of messages ordered by creation time
     */
    func getMessages(mlsGroupId: String, limit: UInt32?, offset: UInt32?) throws  -> [Message]
    
    /**
     * Get pending welcomes with optional pagination
     *
     * # Arguments
     *
     * * `limit` - Optional maximum number of welcomes to return (defaults to 1000 if None)
     * * `offset` - Optional number of welcomes to skip (defaults to 0 if None)
     *
     * # Returns
     *
     * Returns a vector of pending welcomes ordered by ID (descending)
     */
    func getPendingWelcomes(limit: UInt32?, offset: UInt32?) throws  -> [Welcome]
    
    /**
     * Get relays for a group
     */
    func getRelays(mlsGroupId: String) throws  -> [String]
    
    /**
     * Get a welcome by event ID
     */
    func getWelcome(eventId: String) throws  -> Welcome?
    
    /**
     * Create a proposal to leave the group
     */
    func leaveGroup(mlsGroupId: String) throws  -> UpdateGroupResult
    
    /**
     * Merge pending commit for a group
     */
    func mergePendingCommit(mlsGroupId: String) throws 
    
    /**
     * Parse a key package from a Nostr event
     */
    func parseKeyPackage(eventJson: String) throws  -> String
    
    /**
     * Process an incoming MLS message
     */
    func processMessage(eventJson: String) throws  -> ProcessMessageResult
    
    /**
     * Process a welcome message
     */
    func processWelcome(wrapperEventId: String, rumorEventJson: String) throws  -> Welcome
    
    /**
     * Remove members from a group
     */
    func removeMembers(mlsGroupId: String, memberPublicKeys: [String]) throws  -> UpdateGroupResult
    
    /**
     * Update the current member's leaf node in an MLS group
     */
    func selfUpdate(mlsGroupId: String) throws  -> UpdateGroupResult
    
    /**
     * Sync group metadata from MLS
     */
    func syncGroupMetadataFromMls(mlsGroupId: String) throws 
    
    /**
     * Update group data (name, description, image, relays, admins)
     */
    func updateGroupData(mlsGroupId: String, update: GroupDataUpdate) throws  -> UpdateGroupResult
    
}
/**
 * Main MDK instance with SQLite storage
 */
open class Mdk: MdkProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_mdk_uniffi_fn_clone_mdk(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        try! rustCall { uniffi_mdk_uniffi_fn_free_mdk(handle, $0) }
    }

    

    
    /**
     * Accept a welcome message
     */
open func acceptWelcome(welcome: Welcome)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_accept_welcome(
            self.uniffiCloneHandle(),
        FfiConverterTypeWelcome_lower(welcome),$0
    )
}
}
    
    /**
     * Accept a welcome message from JSON
     */
open func acceptWelcomeJson(welcomeJson: String)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_accept_welcome_json(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(welcomeJson),$0
    )
}
}
    
    /**
     * Add members to a group
     */
open func addMembers(mlsGroupId: String, keyPackageEventsJson: [String])throws  -> UpdateGroupResult  {
    return try  FfiConverterTypeUpdateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_add_members(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterSequenceString.lower(keyPackageEventsJson),$0
    )
})
}
    
    /**
     * Create a new group
     */
open func createGroup(creatorPublicKey: String, memberKeyPackageEventsJson: [String], name: String, description: String, relays: [String], admins: [String])throws  -> CreateGroupResult  {
    return try  FfiConverterTypeCreateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_create_group(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(creatorPublicKey),
        FfiConverterSequenceString.lower(memberKeyPackageEventsJson),
        FfiConverterString.lower(name),
        FfiConverterString.lower(description),
        FfiConverterSequenceString.lower(relays),
        FfiConverterSequenceString.lower(admins),$0
    )
})
}
    
    /**
     * Create a key package for a Nostr event
     */
open func createKeyPackageForEvent(publicKey: String, relays: [String])throws  -> KeyPackageResult  {
    return try  FfiConverterTypeKeyPackageResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_create_key_package_for_event(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0
    )
})
}
    
    /**
     * Create a message in a group
     */
open func createMessage(mlsGroupId: String, senderPublicKey: String, content: String, kind: UInt16, tags: [[String]]?)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_create_message(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterString.lower(senderPublicKey),
        FfiConverterString.lower(content),
        FfiConverterUInt16.lower(kind),
        FfiConverterOptionSequenceSequenceString.lower(tags),$0
    )
})
}
    
    /**
     * Decline a welcome message
     */
open func declineWelcome(welcome: Welcome)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_decline_welcome(
            self.uniffiCloneHandle(),
        FfiConverterTypeWelcome_lower(welcome),$0
    )
}
}
    
    /**
     * Decline a welcome message from JSON
     */
open func declineWelcomeJson(welcomeJson: String)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_decline_welcome_json(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(welcomeJson),$0
    )
}
}
    
    /**
     * Get a group by MLS group ID
     */
open func getGroup(mlsGroupId: String)throws  -> Group?  {
    return try  FfiConverterOptionTypeGroup.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_group(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
})
}
    
    /**
     * Get all groups
     */
open func getGroups()throws  -> [Group]  {
    return try  FfiConverterSequenceTypeGroup.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_groups(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get members of a group
     */
open func getMembers(mlsGroupId: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_members(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
})
}
    
    /**
     * Get a message by event ID within a specific group
     *
     * # Arguments
     *
     * * `mls_group_id` - The MLS group ID the message belongs to (hex-encoded)
     * * `event_id` - The Nostr event ID to look up (hex-encoded)
     *
     * # Returns
     *
     * Returns the message if found, None otherwise
     */
open func getMessage(mlsGroupId: String, eventId: String)throws  -> Message?  {
    return try  FfiConverterOptionTypeMessage.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_message(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterString.lower(eventId),$0
    )
})
}
    
    /**
     * Get messages for a group with optional pagination
     *
     * # Arguments
     *
     * * `mls_group_id` - Hex-encoded MLS group ID
     * * `limit` - Optional maximum number of messages to return (defaults to 1000 if None)
     * * `offset` - Optional number of messages to skip (defaults to 0 if None)
     *
     * # Returns
     *
     * Returns a vector of messages ordered by creation time
     */
open func getMessages(mlsGroupId: String, limit: UInt32?, offset: UInt32?)throws  -> [Message]  {
    return try  FfiConverterSequenceTypeMessage.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_messages(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterOptionUInt32.lower(limit),
        FfiConverterOptionUInt32.lower(offset),$0
    )
})
}
    
    /**
     * Get pending welcomes with optional pagination
     *
     * # Arguments
     *
     * * `limit` - Optional maximum number of welcomes to return (defaults to 1000 if None)
     * * `offset` - Optional number of welcomes to skip (defaults to 0 if None)
     *
     * # Returns
     *
     * Returns a vector of pending welcomes ordered by ID (descending)
     */
open func getPendingWelcomes(limit: UInt32?, offset: UInt32?)throws  -> [Welcome]  {
    return try  FfiConverterSequenceTypeWelcome.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_pending_welcomes(
            self.uniffiCloneHandle(),
        FfiConverterOptionUInt32.lower(limit),
        FfiConverterOptionUInt32.lower(offset),$0
    )
})
}
    
    /**
     * Get relays for a group
     */
open func getRelays(mlsGroupId: String)throws  -> [String]  {
    return try  FfiConverterSequenceString.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_relays(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
})
}
    
    /**
     * Get a welcome by event ID
     */
open func getWelcome(eventId: String)throws  -> Welcome?  {
    return try  FfiConverterOptionTypeWelcome.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_get_welcome(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(eventId),$0
    )
})
}
    
    /**
     * Create a proposal to leave the group
     */
open func leaveGroup(mlsGroupId: String)throws  -> UpdateGroupResult  {
    return try  FfiConverterTypeUpdateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_leave_group(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
})
}
    
    /**
     * Merge pending commit for a group
     */
open func mergePendingCommit(mlsGroupId: String)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_merge_pending_commit(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
}
}
    
    /**
     * Parse a key package from a Nostr event
     */
open func parseKeyPackage(eventJson: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_parse_key_package(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(eventJson),$0
    )
})
}
    
    /**
     * Process an incoming MLS message
     */
open func processMessage(eventJson: String)throws  -> ProcessMessageResult  {
    return try  FfiConverterTypeProcessMessageResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_process_message(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(eventJson),$0
    )
})
}
    
    /**
     * Process a welcome message
     */
open func processWelcome(wrapperEventId: String, rumorEventJson: String)throws  -> Welcome  {
    return try  FfiConverterTypeWelcome_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_process_welcome(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(wrapperEventId),
        FfiConverterString.lower(rumorEventJson),$0
    )
})
}
    
    /**
     * Remove members from a group
     */
open func removeMembers(mlsGroupId: String, memberPublicKeys: [String])throws  -> UpdateGroupResult  {
    return try  FfiConverterTypeUpdateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_remove_members(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterSequenceString.lower(memberPublicKeys),$0
    )
})
}
    
    /**
     * Update the current member's leaf node in an MLS group
     */
open func selfUpdate(mlsGroupId: String)throws  -> UpdateGroupResult  {
    return try  FfiConverterTypeUpdateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_self_update(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
})
}
    
    /**
     * Sync group metadata from MLS
     */
open func syncGroupMetadataFromMls(mlsGroupId: String)throws   {try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_sync_group_metadata_from_mls(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),$0
    )
}
}
    
    /**
     * Update group data (name, description, image, relays, admins)
     */
open func updateGroupData(mlsGroupId: String, update: GroupDataUpdate)throws  -> UpdateGroupResult  {
    return try  FfiConverterTypeUpdateGroupResult_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_method_mdk_update_group_data(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(mlsGroupId),
        FfiConverterTypeGroupDataUpdate_lower(update),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdk: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Mdk

    public static func lift(_ handle: UInt64) throws -> Mdk {
        return Mdk(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Mdk) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mdk {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Mdk, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdk_lift(_ handle: UInt64) throws -> Mdk {
    return try FfiConverterTypeMdk.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdk_lower(_ value: Mdk) -> UInt64 {
    return FfiConverterTypeMdk.lower(value)
}




/**
 * Result of creating a group
 */
public struct CreateGroupResult: Equatable, Hashable {
    /**
     * The created group
     */
    public var group: Group
    /**
     * JSON-encoded welcome rumors to be published
     */
    public var welcomeRumorsJson: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The created group
         */group: Group, 
        /**
         * JSON-encoded welcome rumors to be published
         */welcomeRumorsJson: [String]) {
        self.group = group
        self.welcomeRumorsJson = welcomeRumorsJson
    }

    
}

#if compiler(>=6)
extension CreateGroupResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateGroupResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateGroupResult {
        return
            try CreateGroupResult(
                group: FfiConverterTypeGroup.read(from: &buf), 
                welcomeRumorsJson: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateGroupResult, into buf: inout [UInt8]) {
        FfiConverterTypeGroup.write(value.group, into: &buf)
        FfiConverterSequenceString.write(value.welcomeRumorsJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateGroupResult_lift(_ buf: RustBuffer) throws -> CreateGroupResult {
    return try FfiConverterTypeCreateGroupResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateGroupResult_lower(_ value: CreateGroupResult) -> RustBuffer {
    return FfiConverterTypeCreateGroupResult.lower(value)
}


/**
 * Group representation
 */
public struct Group: Equatable, Hashable {
    /**
     * Hex-encoded MLS group ID
     */
    public var mlsGroupId: String
    /**
     * Hex-encoded Nostr group ID
     */
    public var nostrGroupId: String
    /**
     * Group name
     */
    public var name: String
    /**
     * Group description
     */
    public var description: String
    /**
     * Optional group image hash
     */
    public var imageHash: Data?
    /**
     * Optional group image encryption key
     */
    public var imageKey: Data?
    /**
     * Optional group image encryption nonce
     */
    public var imageNonce: Data?
    /**
     * List of admin public keys (hex-encoded)
     */
    public var adminPubkeys: [String]
    /**
     * Last message event ID (hex-encoded)
     */
    public var lastMessageId: String?
    /**
     * Timestamp of last message (Unix timestamp)
     */
    public var lastMessageAt: UInt64?
    /**
     * Current epoch number
     */
    public var epoch: UInt64
    /**
     * Group state (e.g., "active", "archived")
     */
    public var state: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded MLS group ID
         */mlsGroupId: String, 
        /**
         * Hex-encoded Nostr group ID
         */nostrGroupId: String, 
        /**
         * Group name
         */name: String, 
        /**
         * Group description
         */description: String, 
        /**
         * Optional group image hash
         */imageHash: Data?, 
        /**
         * Optional group image encryption key
         */imageKey: Data?, 
        /**
         * Optional group image encryption nonce
         */imageNonce: Data?, 
        /**
         * List of admin public keys (hex-encoded)
         */adminPubkeys: [String], 
        /**
         * Last message event ID (hex-encoded)
         */lastMessageId: String?, 
        /**
         * Timestamp of last message (Unix timestamp)
         */lastMessageAt: UInt64?, 
        /**
         * Current epoch number
         */epoch: UInt64, 
        /**
         * Group state (e.g., "active", "archived")
         */state: String) {
        self.mlsGroupId = mlsGroupId
        self.nostrGroupId = nostrGroupId
        self.name = name
        self.description = description
        self.imageHash = imageHash
        self.imageKey = imageKey
        self.imageNonce = imageNonce
        self.adminPubkeys = adminPubkeys
        self.lastMessageId = lastMessageId
        self.lastMessageAt = lastMessageAt
        self.epoch = epoch
        self.state = state
    }

    
}

#if compiler(>=6)
extension Group: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroup: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Group {
        return
            try Group(
                mlsGroupId: FfiConverterString.read(from: &buf), 
                nostrGroupId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterString.read(from: &buf), 
                imageHash: FfiConverterOptionData.read(from: &buf), 
                imageKey: FfiConverterOptionData.read(from: &buf), 
                imageNonce: FfiConverterOptionData.read(from: &buf), 
                adminPubkeys: FfiConverterSequenceString.read(from: &buf), 
                lastMessageId: FfiConverterOptionString.read(from: &buf), 
                lastMessageAt: FfiConverterOptionUInt64.read(from: &buf), 
                epoch: FfiConverterUInt64.read(from: &buf), 
                state: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Group, into buf: inout [UInt8]) {
        FfiConverterString.write(value.mlsGroupId, into: &buf)
        FfiConverterString.write(value.nostrGroupId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.description, into: &buf)
        FfiConverterOptionData.write(value.imageHash, into: &buf)
        FfiConverterOptionData.write(value.imageKey, into: &buf)
        FfiConverterOptionData.write(value.imageNonce, into: &buf)
        FfiConverterSequenceString.write(value.adminPubkeys, into: &buf)
        FfiConverterOptionString.write(value.lastMessageId, into: &buf)
        FfiConverterOptionUInt64.write(value.lastMessageAt, into: &buf)
        FfiConverterUInt64.write(value.epoch, into: &buf)
        FfiConverterString.write(value.state, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lift(_ buf: RustBuffer) throws -> Group {
    return try FfiConverterTypeGroup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroup_lower(_ value: Group) -> RustBuffer {
    return FfiConverterTypeGroup.lower(value)
}


/**
 * Configuration for updating group data with optional fields
 */
public struct GroupDataUpdate: Equatable, Hashable {
    /**
     * Group name (optional)
     */
    public var name: String?
    /**
     * Group description (optional)
     */
    public var description: String?
    /**
     * Group image hash (optional, use Some(None) to clear)
     */
    public var imageHash: Data??
    /**
     * Group image encryption key (optional, use Some(None) to clear)
     */
    public var imageKey: Data??
    /**
     * Group image encryption nonce (optional, use Some(None) to clear)
     */
    public var imageNonce: Data??
    /**
     * Relays used by the group (optional)
     */
    public var relays: [String]?
    /**
     * Group admins (optional)
     */
    public var admins: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Group name (optional)
         */name: String?, 
        /**
         * Group description (optional)
         */description: String?, 
        /**
         * Group image hash (optional, use Some(None) to clear)
         */imageHash: Data??, 
        /**
         * Group image encryption key (optional, use Some(None) to clear)
         */imageKey: Data??, 
        /**
         * Group image encryption nonce (optional, use Some(None) to clear)
         */imageNonce: Data??, 
        /**
         * Relays used by the group (optional)
         */relays: [String]?, 
        /**
         * Group admins (optional)
         */admins: [String]?) {
        self.name = name
        self.description = description
        self.imageHash = imageHash
        self.imageKey = imageKey
        self.imageNonce = imageNonce
        self.relays = relays
        self.admins = admins
    }

    
}

#if compiler(>=6)
extension GroupDataUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupDataUpdate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupDataUpdate {
        return
            try GroupDataUpdate(
                name: FfiConverterOptionString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                imageHash: FfiConverterOptionOptionData.read(from: &buf), 
                imageKey: FfiConverterOptionOptionData.read(from: &buf), 
                imageNonce: FfiConverterOptionOptionData.read(from: &buf), 
                relays: FfiConverterOptionSequenceString.read(from: &buf), 
                admins: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupDataUpdate, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionOptionData.write(value.imageHash, into: &buf)
        FfiConverterOptionOptionData.write(value.imageKey, into: &buf)
        FfiConverterOptionOptionData.write(value.imageNonce, into: &buf)
        FfiConverterOptionSequenceString.write(value.relays, into: &buf)
        FfiConverterOptionSequenceString.write(value.admins, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupDataUpdate_lift(_ buf: RustBuffer) throws -> GroupDataUpdate {
    return try FfiConverterTypeGroupDataUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupDataUpdate_lower(_ value: GroupDataUpdate) -> RustBuffer {
    return FfiConverterTypeGroupDataUpdate.lower(value)
}


/**
 * Prepared group image data ready for upload to Blossom
 */
public struct GroupImageUpload: Equatable, Hashable {
    /**
     * Encrypted image data (ready to upload to Blossom)
     */
    public var encryptedData: Data
    /**
     * SHA256 hash of encrypted data (verify against Blossom response)
     */
    public var encryptedHash: Data
    /**
     * Encryption key (store in extension)
     */
    public var imageKey: Data
    /**
     * Encryption nonce (store in extension)
     */
    public var imageNonce: Data
    /**
     * Derived keypair secret for Blossom authentication (hex encoded)
     */
    public var uploadSecretKey: String
    /**
     * Original image size before encryption
     */
    public var originalSize: UInt64
    /**
     * Size after encryption
     */
    public var encryptedSize: UInt64
    /**
     * Validated and canonical MIME type
     */
    public var mimeType: String
    /**
     * Image dimensions (width, height) if available
     */
    public var dimensions: ImageDimensions?
    /**
     * Blurhash for preview if generated
     */
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encrypted image data (ready to upload to Blossom)
         */encryptedData: Data, 
        /**
         * SHA256 hash of encrypted data (verify against Blossom response)
         */encryptedHash: Data, 
        /**
         * Encryption key (store in extension)
         */imageKey: Data, 
        /**
         * Encryption nonce (store in extension)
         */imageNonce: Data, 
        /**
         * Derived keypair secret for Blossom authentication (hex encoded)
         */uploadSecretKey: String, 
        /**
         * Original image size before encryption
         */originalSize: UInt64, 
        /**
         * Size after encryption
         */encryptedSize: UInt64, 
        /**
         * Validated and canonical MIME type
         */mimeType: String, 
        /**
         * Image dimensions (width, height) if available
         */dimensions: ImageDimensions?, 
        /**
         * Blurhash for preview if generated
         */blurhash: String?) {
        self.encryptedData = encryptedData
        self.encryptedHash = encryptedHash
        self.imageKey = imageKey
        self.imageNonce = imageNonce
        self.uploadSecretKey = uploadSecretKey
        self.originalSize = originalSize
        self.encryptedSize = encryptedSize
        self.mimeType = mimeType
        self.dimensions = dimensions
        self.blurhash = blurhash
    }

    
}

#if compiler(>=6)
extension GroupImageUpload: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGroupImageUpload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GroupImageUpload {
        return
            try GroupImageUpload(
                encryptedData: FfiConverterData.read(from: &buf), 
                encryptedHash: FfiConverterData.read(from: &buf), 
                imageKey: FfiConverterData.read(from: &buf), 
                imageNonce: FfiConverterData.read(from: &buf), 
                uploadSecretKey: FfiConverterString.read(from: &buf), 
                originalSize: FfiConverterUInt64.read(from: &buf), 
                encryptedSize: FfiConverterUInt64.read(from: &buf), 
                mimeType: FfiConverterString.read(from: &buf), 
                dimensions: FfiConverterOptionTypeImageDimensions.read(from: &buf), 
                blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: GroupImageUpload, into buf: inout [UInt8]) {
        FfiConverterData.write(value.encryptedData, into: &buf)
        FfiConverterData.write(value.encryptedHash, into: &buf)
        FfiConverterData.write(value.imageKey, into: &buf)
        FfiConverterData.write(value.imageNonce, into: &buf)
        FfiConverterString.write(value.uploadSecretKey, into: &buf)
        FfiConverterUInt64.write(value.originalSize, into: &buf)
        FfiConverterUInt64.write(value.encryptedSize, into: &buf)
        FfiConverterString.write(value.mimeType, into: &buf)
        FfiConverterOptionTypeImageDimensions.write(value.dimensions, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupImageUpload_lift(_ buf: RustBuffer) throws -> GroupImageUpload {
    return try FfiConverterTypeGroupImageUpload.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGroupImageUpload_lower(_ value: GroupImageUpload) -> RustBuffer {
    return FfiConverterTypeGroupImageUpload.lower(value)
}


/**
 * Image dimensions
 */
public struct ImageDimensions: Equatable, Hashable {
    /**
     * Width in pixels
     */
    public var width: UInt32
    /**
     * Height in pixels
     */
    public var height: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Width in pixels
         */width: UInt32, 
        /**
         * Height in pixels
         */height: UInt32) {
        self.width = width
        self.height = height
    }

    
}

#if compiler(>=6)
extension ImageDimensions: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageDimensions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageDimensions {
        return
            try ImageDimensions(
                width: FfiConverterUInt32.read(from: &buf), 
                height: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: ImageDimensions, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.width, into: &buf)
        FfiConverterUInt32.write(value.height, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageDimensions_lift(_ buf: RustBuffer) throws -> ImageDimensions {
    return try FfiConverterTypeImageDimensions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageDimensions_lower(_ value: ImageDimensions) -> RustBuffer {
    return FfiConverterTypeImageDimensions.lower(value)
}


/**
 * Result of creating a key package
 */
public struct KeyPackageResult: Equatable, Hashable {
    /**
     * Hex-encoded key package
     */
    public var keyPackage: String
    /**
     * JSON-encoded tags for the key package event
     */
    public var tags: [[String]]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hex-encoded key package
         */keyPackage: String, 
        /**
         * JSON-encoded tags for the key package event
         */tags: [[String]]) {
        self.keyPackage = keyPackage
        self.tags = tags
    }

    
}

#if compiler(>=6)
extension KeyPackageResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyPackageResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyPackageResult {
        return
            try KeyPackageResult(
                keyPackage: FfiConverterString.read(from: &buf), 
                tags: FfiConverterSequenceSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: KeyPackageResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.keyPackage, into: &buf)
        FfiConverterSequenceSequenceString.write(value.tags, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageResult_lift(_ buf: RustBuffer) throws -> KeyPackageResult {
    return try FfiConverterTypeKeyPackageResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyPackageResult_lower(_ value: KeyPackageResult) -> RustBuffer {
    return FfiConverterTypeKeyPackageResult.lower(value)
}


/**
 * Configuration for MDK behavior
 *
 * This struct allows customization of various MDK parameters including
 * message validation and MLS sender ratchet settings. All fields are optional
 * and default to sensible values when not provided.
 */
public struct MdkConfig: Equatable, Hashable {
    /**
     * Maximum age for accepted events in seconds.
     * Default: 3888000 (45 days)
     */
    public var maxEventAgeSecs: UInt64?
    /**
     * Maximum future timestamp skew allowed in seconds.
     * Default: 300 (5 minutes)
     */
    public var maxFutureSkewSecs: UInt64?
    /**
     * Number of past message decryption secrets to retain for out-of-order delivery.
     * Higher values improve tolerance for reordered messages but reduce forward secrecy.
     * Default: 100
     */
    public var outOfOrderTolerance: UInt32?
    /**
     * Maximum number of messages that can be skipped before decryption fails.
     * Default: 1000
     */
    public var maximumForwardDistance: UInt32?
    /**
     * Number of epoch snapshots to retain for rollback support.
     * Default: 5
     */
    public var epochSnapshotRetention: UInt32?
    /**
     * Time-to-live for snapshots in seconds.
     * Snapshots older than this will be pruned on startup.
     * Default: 604800 (1 week)
     */
    public var snapshotTtlSeconds: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Maximum age for accepted events in seconds.
         * Default: 3888000 (45 days)
         */maxEventAgeSecs: UInt64?, 
        /**
         * Maximum future timestamp skew allowed in seconds.
         * Default: 300 (5 minutes)
         */maxFutureSkewSecs: UInt64?, 
        /**
         * Number of past message decryption secrets to retain for out-of-order delivery.
         * Higher values improve tolerance for reordered messages but reduce forward secrecy.
         * Default: 100
         */outOfOrderTolerance: UInt32?, 
        /**
         * Maximum number of messages that can be skipped before decryption fails.
         * Default: 1000
         */maximumForwardDistance: UInt32?, 
        /**
         * Number of epoch snapshots to retain for rollback support.
         * Default: 5
         */epochSnapshotRetention: UInt32?, 
        /**
         * Time-to-live for snapshots in seconds.
         * Snapshots older than this will be pruned on startup.
         * Default: 604800 (1 week)
         */snapshotTtlSeconds: UInt64?) {
        self.maxEventAgeSecs = maxEventAgeSecs
        self.maxFutureSkewSecs = maxFutureSkewSecs
        self.outOfOrderTolerance = outOfOrderTolerance
        self.maximumForwardDistance = maximumForwardDistance
        self.epochSnapshotRetention = epochSnapshotRetention
        self.snapshotTtlSeconds = snapshotTtlSeconds
    }

    
}

#if compiler(>=6)
extension MdkConfig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdkConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdkConfig {
        return
            try MdkConfig(
                maxEventAgeSecs: FfiConverterOptionUInt64.read(from: &buf), 
                maxFutureSkewSecs: FfiConverterOptionUInt64.read(from: &buf), 
                outOfOrderTolerance: FfiConverterOptionUInt32.read(from: &buf), 
                maximumForwardDistance: FfiConverterOptionUInt32.read(from: &buf), 
                epochSnapshotRetention: FfiConverterOptionUInt32.read(from: &buf), 
                snapshotTtlSeconds: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MdkConfig, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.maxEventAgeSecs, into: &buf)
        FfiConverterOptionUInt64.write(value.maxFutureSkewSecs, into: &buf)
        FfiConverterOptionUInt32.write(value.outOfOrderTolerance, into: &buf)
        FfiConverterOptionUInt32.write(value.maximumForwardDistance, into: &buf)
        FfiConverterOptionUInt32.write(value.epochSnapshotRetention, into: &buf)
        FfiConverterOptionUInt64.write(value.snapshotTtlSeconds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdkConfig_lift(_ buf: RustBuffer) throws -> MdkConfig {
    return try FfiConverterTypeMdkConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdkConfig_lower(_ value: MdkConfig) -> RustBuffer {
    return FfiConverterTypeMdkConfig.lower(value)
}


/**
 * Message representation
 */
public struct Message: Equatable, Hashable {
    /**
     * Message ID (hex-encoded event ID)
     */
    public var id: String
    /**
     * Hex-encoded MLS group ID
     */
    public var mlsGroupId: String
    /**
     * Hex-encoded Nostr group ID
     */
    public var nostrGroupId: String
    /**
     * Event ID (hex-encoded)
     */
    public var eventId: String
    /**
     * Sender public key (hex-encoded)
     */
    public var senderPubkey: String
    /**
     * JSON representation of the event
     */
    public var eventJson: String
    /**
     * Timestamp when message was processed (Unix timestamp)
     */
    public var processedAt: UInt64
    /**
     * Message kind
     */
    public var kind: UInt16
    /**
     * Message state (e.g., "processed", "pending")
     */
    public var state: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Message ID (hex-encoded event ID)
         */id: String, 
        /**
         * Hex-encoded MLS group ID
         */mlsGroupId: String, 
        /**
         * Hex-encoded Nostr group ID
         */nostrGroupId: String, 
        /**
         * Event ID (hex-encoded)
         */eventId: String, 
        /**
         * Sender public key (hex-encoded)
         */senderPubkey: String, 
        /**
         * JSON representation of the event
         */eventJson: String, 
        /**
         * Timestamp when message was processed (Unix timestamp)
         */processedAt: UInt64, 
        /**
         * Message kind
         */kind: UInt16, 
        /**
         * Message state (e.g., "processed", "pending")
         */state: String) {
        self.id = id
        self.mlsGroupId = mlsGroupId
        self.nostrGroupId = nostrGroupId
        self.eventId = eventId
        self.senderPubkey = senderPubkey
        self.eventJson = eventJson
        self.processedAt = processedAt
        self.kind = kind
        self.state = state
    }

    
}

#if compiler(>=6)
extension Message: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Message {
        return
            try Message(
                id: FfiConverterString.read(from: &buf), 
                mlsGroupId: FfiConverterString.read(from: &buf), 
                nostrGroupId: FfiConverterString.read(from: &buf), 
                eventId: FfiConverterString.read(from: &buf), 
                senderPubkey: FfiConverterString.read(from: &buf), 
                eventJson: FfiConverterString.read(from: &buf), 
                processedAt: FfiConverterUInt64.read(from: &buf), 
                kind: FfiConverterUInt16.read(from: &buf), 
                state: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Message, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.mlsGroupId, into: &buf)
        FfiConverterString.write(value.nostrGroupId, into: &buf)
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterString.write(value.senderPubkey, into: &buf)
        FfiConverterString.write(value.eventJson, into: &buf)
        FfiConverterUInt64.write(value.processedAt, into: &buf)
        FfiConverterUInt16.write(value.kind, into: &buf)
        FfiConverterString.write(value.state, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lift(_ buf: RustBuffer) throws -> Message {
    return try FfiConverterTypeMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessage_lower(_ value: Message) -> RustBuffer {
    return FfiConverterTypeMessage.lower(value)
}


/**
 * Result of updating a group
 */
public struct UpdateGroupResult: Equatable, Hashable {
    /**
     * JSON-encoded evolution event to be published
     */
    public var evolutionEventJson: String
    /**
     * Optional JSON-encoded welcome rumors to be published
     */
    public var welcomeRumorsJson: [String]?
    /**
     * Hex-encoded MLS group ID
     */
    public var mlsGroupId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * JSON-encoded evolution event to be published
         */evolutionEventJson: String, 
        /**
         * Optional JSON-encoded welcome rumors to be published
         */welcomeRumorsJson: [String]?, 
        /**
         * Hex-encoded MLS group ID
         */mlsGroupId: String) {
        self.evolutionEventJson = evolutionEventJson
        self.welcomeRumorsJson = welcomeRumorsJson
        self.mlsGroupId = mlsGroupId
    }

    
}

#if compiler(>=6)
extension UpdateGroupResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUpdateGroupResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdateGroupResult {
        return
            try UpdateGroupResult(
                evolutionEventJson: FfiConverterString.read(from: &buf), 
                welcomeRumorsJson: FfiConverterOptionSequenceString.read(from: &buf), 
                mlsGroupId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UpdateGroupResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.evolutionEventJson, into: &buf)
        FfiConverterOptionSequenceString.write(value.welcomeRumorsJson, into: &buf)
        FfiConverterString.write(value.mlsGroupId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateGroupResult_lift(_ buf: RustBuffer) throws -> UpdateGroupResult {
    return try FfiConverterTypeUpdateGroupResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUpdateGroupResult_lower(_ value: UpdateGroupResult) -> RustBuffer {
    return FfiConverterTypeUpdateGroupResult.lower(value)
}


/**
 * Welcome representation
 */
public struct Welcome: Equatable, Hashable {
    /**
     * Welcome ID (hex-encoded event ID)
     */
    public var id: String
    /**
     * JSON representation of the welcome event
     */
    public var eventJson: String
    /**
     * Hex-encoded MLS group ID
     */
    public var mlsGroupId: String
    /**
     * Hex-encoded Nostr group ID
     */
    public var nostrGroupId: String
    /**
     * Group name
     */
    public var groupName: String
    /**
     * Group description
     */
    public var groupDescription: String
    /**
     * Optional group image hash
     */
    public var groupImageHash: Data?
    /**
     * Optional group image encryption key
     */
    public var groupImageKey: Data?
    /**
     * Optional group image encryption nonce
     */
    public var groupImageNonce: Data?
    /**
     * List of admin public keys (hex-encoded)
     */
    public var groupAdminPubkeys: [String]
    /**
     * List of relay URLs for the group
     */
    public var groupRelays: [String]
    /**
     * Welcomer public key (hex-encoded)
     */
    public var welcomer: String
    /**
     * Current member count
     */
    public var memberCount: UInt32
    /**
     * Welcome state (e.g., "pending", "accepted", "declined")
     */
    public var state: String
    /**
     * Wrapper event ID (hex-encoded)
     */
    public var wrapperEventId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Welcome ID (hex-encoded event ID)
         */id: String, 
        /**
         * JSON representation of the welcome event
         */eventJson: String, 
        /**
         * Hex-encoded MLS group ID
         */mlsGroupId: String, 
        /**
         * Hex-encoded Nostr group ID
         */nostrGroupId: String, 
        /**
         * Group name
         */groupName: String, 
        /**
         * Group description
         */groupDescription: String, 
        /**
         * Optional group image hash
         */groupImageHash: Data?, 
        /**
         * Optional group image encryption key
         */groupImageKey: Data?, 
        /**
         * Optional group image encryption nonce
         */groupImageNonce: Data?, 
        /**
         * List of admin public keys (hex-encoded)
         */groupAdminPubkeys: [String], 
        /**
         * List of relay URLs for the group
         */groupRelays: [String], 
        /**
         * Welcomer public key (hex-encoded)
         */welcomer: String, 
        /**
         * Current member count
         */memberCount: UInt32, 
        /**
         * Welcome state (e.g., "pending", "accepted", "declined")
         */state: String, 
        /**
         * Wrapper event ID (hex-encoded)
         */wrapperEventId: String) {
        self.id = id
        self.eventJson = eventJson
        self.mlsGroupId = mlsGroupId
        self.nostrGroupId = nostrGroupId
        self.groupName = groupName
        self.groupDescription = groupDescription
        self.groupImageHash = groupImageHash
        self.groupImageKey = groupImageKey
        self.groupImageNonce = groupImageNonce
        self.groupAdminPubkeys = groupAdminPubkeys
        self.groupRelays = groupRelays
        self.welcomer = welcomer
        self.memberCount = memberCount
        self.state = state
        self.wrapperEventId = wrapperEventId
    }

    
}

#if compiler(>=6)
extension Welcome: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWelcome: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Welcome {
        return
            try Welcome(
                id: FfiConverterString.read(from: &buf), 
                eventJson: FfiConverterString.read(from: &buf), 
                mlsGroupId: FfiConverterString.read(from: &buf), 
                nostrGroupId: FfiConverterString.read(from: &buf), 
                groupName: FfiConverterString.read(from: &buf), 
                groupDescription: FfiConverterString.read(from: &buf), 
                groupImageHash: FfiConverterOptionData.read(from: &buf), 
                groupImageKey: FfiConverterOptionData.read(from: &buf), 
                groupImageNonce: FfiConverterOptionData.read(from: &buf), 
                groupAdminPubkeys: FfiConverterSequenceString.read(from: &buf), 
                groupRelays: FfiConverterSequenceString.read(from: &buf), 
                welcomer: FfiConverterString.read(from: &buf), 
                memberCount: FfiConverterUInt32.read(from: &buf), 
                state: FfiConverterString.read(from: &buf), 
                wrapperEventId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Welcome, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.eventJson, into: &buf)
        FfiConverterString.write(value.mlsGroupId, into: &buf)
        FfiConverterString.write(value.nostrGroupId, into: &buf)
        FfiConverterString.write(value.groupName, into: &buf)
        FfiConverterString.write(value.groupDescription, into: &buf)
        FfiConverterOptionData.write(value.groupImageHash, into: &buf)
        FfiConverterOptionData.write(value.groupImageKey, into: &buf)
        FfiConverterOptionData.write(value.groupImageNonce, into: &buf)
        FfiConverterSequenceString.write(value.groupAdminPubkeys, into: &buf)
        FfiConverterSequenceString.write(value.groupRelays, into: &buf)
        FfiConverterString.write(value.welcomer, into: &buf)
        FfiConverterUInt32.write(value.memberCount, into: &buf)
        FfiConverterString.write(value.state, into: &buf)
        FfiConverterString.write(value.wrapperEventId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWelcome_lift(_ buf: RustBuffer) throws -> Welcome {
    return try FfiConverterTypeWelcome.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWelcome_lower(_ value: Welcome) -> RustBuffer {
    return FfiConverterTypeWelcome.lower(value)
}


/**
 * Error type for MDK UniFFI operations
 */
public enum MdkUniffiError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * Storage-related error
     */
    case Storage(String
    )
    /**
     * MDK core error
     */
    case Mdk(String
    )
    /**
     * Invalid input parameter error
     */
    case InvalidInput(String
    )

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MdkUniffiError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMdkUniffiError: FfiConverterRustBuffer {
    typealias SwiftType = MdkUniffiError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MdkUniffiError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Storage(
            try FfiConverterString.read(from: &buf)
            )
        case 2: return .Mdk(
            try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidInput(
            try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MdkUniffiError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Storage(v1):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .Mdk(v1):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(v1, into: &buf)
            
        
        case let .InvalidInput(v1):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdkUniffiError_lift(_ buf: RustBuffer) throws -> MdkUniffiError {
    return try FfiConverterTypeMdkUniffiError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMdkUniffiError_lower(_ value: MdkUniffiError) -> RustBuffer {
    return FfiConverterTypeMdkUniffiError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Result of processing a message
 */

public enum ProcessMessageResult: Equatable, Hashable {
    
    /**
     * An application message (usually a chat message)
     */
    case applicationMessage(
        /**
         * The processed message
         */message: Message
    )
    /**
     * A proposal message that was auto-committed by an admin receiver
     */
    case proposal(
        /**
         * The proposal result containing evolution event and welcome rumors
         */result: UpdateGroupResult
    )
    /**
     * A pending proposal stored but not committed (receiver is not admin)
     */
    case pendingProposal(
        /**
         * Hex-encoded MLS group ID this pending proposal belongs to
         */mlsGroupId: String
    )
    /**
     * External join proposal
     */
    case externalJoinProposal(
        /**
         * Hex-encoded MLS group ID this proposal belongs to
         */mlsGroupId: String
    )
    /**
     * Commit message
     */
    case commit(
        /**
         * Hex-encoded MLS group ID this commit applies to
         */mlsGroupId: String
    )
    /**
     * Unprocessable message
     */
    case unprocessable(
        /**
         * Hex-encoded MLS group ID of the message that could not be processed
         */mlsGroupId: String
    )
    /**
     * Proposal was ignored and not stored
     */
    case ignoredProposal(
        /**
         * Hex-encoded MLS group ID this proposal was for
         */mlsGroupId: String, 
        /**
         * Reason the proposal was ignored
         */reason: String
    )



}

#if compiler(>=6)
extension ProcessMessageResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProcessMessageResult: FfiConverterRustBuffer {
    typealias SwiftType = ProcessMessageResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProcessMessageResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .applicationMessage(message: try FfiConverterTypeMessage.read(from: &buf)
        )
        
        case 2: return .proposal(result: try FfiConverterTypeUpdateGroupResult.read(from: &buf)
        )
        
        case 3: return .pendingProposal(mlsGroupId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .externalJoinProposal(mlsGroupId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .commit(mlsGroupId: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .unprocessable(mlsGroupId: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .ignoredProposal(mlsGroupId: try FfiConverterString.read(from: &buf), reason: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProcessMessageResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .applicationMessage(message):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessage.write(message, into: &buf)
            
        
        case let .proposal(result):
            writeInt(&buf, Int32(2))
            FfiConverterTypeUpdateGroupResult.write(result, into: &buf)
            
        
        case let .pendingProposal(mlsGroupId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(mlsGroupId, into: &buf)
            
        
        case let .externalJoinProposal(mlsGroupId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(mlsGroupId, into: &buf)
            
        
        case let .commit(mlsGroupId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(mlsGroupId, into: &buf)
            
        
        case let .unprocessable(mlsGroupId):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(mlsGroupId, into: &buf)
            
        
        case let .ignoredProposal(mlsGroupId,reason):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(mlsGroupId, into: &buf)
            FfiConverterString.write(reason, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProcessMessageResult_lift(_ buf: RustBuffer) throws -> ProcessMessageResult {
    return try FfiConverterTypeProcessMessageResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProcessMessageResult_lower(_ value: ProcessMessageResult) -> RustBuffer {
    return FfiConverterTypeProcessMessageResult.lower(value)
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeGroup: FfiConverterRustBuffer {
    typealias SwiftType = Group?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGroup.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGroup.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImageDimensions: FfiConverterRustBuffer {
    typealias SwiftType = ImageDimensions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageDimensions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageDimensions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMdkConfig: FfiConverterRustBuffer {
    typealias SwiftType = MdkConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMdkConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMdkConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = Message?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMessage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMessage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeWelcome: FfiConverterRustBuffer {
    typealias SwiftType = Welcome?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeWelcome.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeWelcome.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data??

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterOptionData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterOptionData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGroup: FfiConverterRustBuffer {
    typealias SwiftType = [Group]

    public static func write(_ value: [Group], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGroup.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Group] {
        let len: Int32 = try readInt(&buf)
        var seq = [Group]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGroup.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMessage: FfiConverterRustBuffer {
    typealias SwiftType = [Message]

    public static func write(_ value: [Message], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMessage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Message] {
        let len: Int32 = try readInt(&buf)
        var seq = [Message]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMessage.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWelcome: FfiConverterRustBuffer {
    typealias SwiftType = [Welcome]

    public static func write(_ value: [Welcome], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWelcome.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Welcome] {
        let len: Int32 = try readInt(&buf)
        var seq = [Welcome]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWelcome.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}
/**
 * Decrypt group image
 */
public func decryptGroupImage(encryptedData: Data, expectedHash: Data?, imageKey: Data, imageNonce: Data)throws  -> Data  {
    return try  FfiConverterData.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_decrypt_group_image(
        FfiConverterData.lower(encryptedData),
        FfiConverterOptionData.lower(expectedHash),
        FfiConverterData.lower(imageKey),
        FfiConverterData.lower(imageNonce),$0
    )
})
}
/**
 * Derive upload keypair for group image
 */
public func deriveUploadKeypair(imageKey: Data, version: UInt16)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_derive_upload_keypair(
        FfiConverterData.lower(imageKey),
        FfiConverterUInt16.lower(version),$0
    )
})
}
/**
 * Create a new MDK instance with encrypted SQLite storage using automatic key management.
 *
 * This is the recommended constructor for production use. The database encryption key
 * is automatically retrieved from (or generated and stored in) the platform's native
 * keyring (Keychain on macOS/iOS, Keystore on Android, etc.).
 *
 * # Prerequisites
 *
 * The host application must initialize a platform-specific keyring store before calling
 * this function:
 *
 * - **macOS/iOS**: `keyring_core::set_default_store(AppleStore::new())`
 * - **Android**: Initialize from Kotlin (see Android documentation)
 * - **Windows**: `keyring_core::set_default_store(WindowsStore::new())`
 * - **Linux**: `keyring_core::set_default_store(KeyutilsStore::new())`
 *
 * # Arguments
 *
 * * `db_path` - Path to the SQLite database file
 * * `service_id` - A stable, host-defined application identifier (e.g., "com.example.myapp")
 * * `db_key_id` - A stable identifier for this database's key (e.g., "mdk.db.key.default")
 * * `config` - Optional MDK configuration. If None, uses default configuration.
 *
 * # Errors
 *
 * Returns an error if:
 * - No keyring store has been initialized
 * - The keyring is unavailable or inaccessible
 * - The database cannot be opened or created
 */
public func newMdk(dbPath: String, serviceId: String, dbKeyId: String, config: MdkConfig?)throws  -> Mdk  {
    return try  FfiConverterTypeMdk_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_new_mdk(
        FfiConverterString.lower(dbPath),
        FfiConverterString.lower(serviceId),
        FfiConverterString.lower(dbKeyId),
        FfiConverterOptionTypeMdkConfig.lower(config),$0
    )
})
}
/**
 * Create a new MDK instance with unencrypted SQLite storage.
 *
 *  **WARNING**: This creates an unencrypted database. Sensitive MLS state
 * including exporter secrets will be stored in plaintext.
 *
 * Only use this for development or testing. For production use, use `new_mdk`
 * with an encryption key.
 *
 * # Arguments
 *
 * * `db_path` - Path to the SQLite database file
 * * `config` - Optional MDK configuration. If None, uses default configuration.
 */
public func newMdkUnencrypted(dbPath: String, config: MdkConfig?)throws  -> Mdk  {
    return try  FfiConverterTypeMdk_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_new_mdk_unencrypted(
        FfiConverterString.lower(dbPath),
        FfiConverterOptionTypeMdkConfig.lower(config),$0
    )
})
}
/**
 * Create a new MDK instance with encrypted SQLite storage using a directly provided key.
 *
 * Use this when you want to manage encryption keys yourself rather than using the
 * platform keyring. For most applications, prefer `new_mdk` which handles key
 * management automatically.
 *
 * # Arguments
 *
 * * `db_path` - Path to the SQLite database file
 * * `encryption_key` - 32-byte encryption key (must be exactly 32 bytes)
 * * `config` - Optional MDK configuration. If None, uses default configuration.
 *
 * # Errors
 *
 * Returns an error if the key is not 32 bytes or if the database cannot be opened.
 */
public func newMdkWithKey(dbPath: String, encryptionKey: Data, config: MdkConfig?)throws  -> Mdk  {
    return try  FfiConverterTypeMdk_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_new_mdk_with_key(
        FfiConverterString.lower(dbPath),
        FfiConverterData.lower(encryptionKey),
        FfiConverterOptionTypeMdkConfig.lower(config),$0
    )
})
}
/**
 * Prepare group image for upload
 */
public func prepareGroupImageForUpload(imageData: Data, mimeType: String)throws  -> GroupImageUpload  {
    return try  FfiConverterTypeGroupImageUpload_lift(try rustCallWithError(FfiConverterTypeMdkUniffiError_lift) {
    uniffi_mdk_uniffi_fn_func_prepare_group_image_for_upload(
        FfiConverterData.lower(imageData),
        FfiConverterString.lower(mimeType),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_mdk_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_decrypt_group_image() != 29409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_derive_upload_keypair() != 45595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_new_mdk() != 40772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_new_mdk_unencrypted() != 29834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_new_mdk_with_key() != 29974) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_func_prepare_group_image_for_upload() != 65092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome() != 3695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_accept_welcome_json() != 39652) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_add_members() != 19089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_create_group() != 56895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_create_key_package_for_event() != 48232) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_create_message() != 58601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome() != 57917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_decline_welcome_json() != 21478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_group() != 1495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_groups() != 20872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_members() != 9763) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_message() != 47057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_messages() != 36057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_pending_welcomes() != 31211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_relays() != 55523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_get_welcome() != 25012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_leave_group() != 46166) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_merge_pending_commit() != 22201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_parse_key_package() != 41870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_process_message() != 15589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_process_welcome() != 34932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_remove_members() != 31926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_self_update() != 48999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_sync_group_metadata_from_mls() != 16922) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_mdk_uniffi_checksum_method_mdk_update_group_data() != 32068) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureMdkUniffiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all